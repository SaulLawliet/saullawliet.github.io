#+TITLE: Java 笔记
#+LANGUAGE: en
#+OPTIONS: H:3 num:nil toc:t \n:t

* 技术博客推荐
- 美团技术团队 https://tech.meituan.com/tags/java.html

* Java 主流锁
- 线程要不要锁住同步资源?
  - 锁住: *悲观锁*
  - 不锁住: *乐观锁*
- 锁住同步资源失败, 线程要不要阻塞?
  - 阻塞
  - 不阻塞: *自旋锁* / *适应性自旋锁*
- 多个线程竞争同步资源的流程细节有没有区别?
  - 不锁住资源, 多个线程中只有一个能修改资源成功, 其它线程会重试: *无锁*
  - 同一个线程执行同步资源时自动获取资源: *偏向锁*
  - 多个线程竞争同步资源时, 没有获取资源的线程自旋等待锁释放: *轻量级锁*
  - 多个线程竞争同步资源时, 没有获取资源的线程阻塞等待唤醒: *重量级锁*
- 多个线程竞争锁时要不要排队?
  - 排队: *公平锁*
  - 先尝试插队, 插队失败再排队: *非公平锁*
- 一个线程中的多个线程能不能获得同一把锁?
  - 能: *可重入锁*
  - 不能: *不可重入锁*
- 多个线程能不能共享一把锁?
  - 能: *共享锁*
  - 不能: *互斥锁(排他锁)*

** 悲观锁 vs 乐观锁
  - 悲观锁: 使用前加锁, 使用后释放锁. 例如: synchronized 与 Lock
  - 乐观锁: 在更新数据前判断有没有别的线程更新了这个值. 例如: Atomic 相关类, 底层使用 volatile 和 CAS 算法.

** 自旋锁 vs 适应性自旋锁
- 自旋锁: 不放弃 CPU 时间片, 通过 for(;;) {...} 等待锁释放.
- 适应性自旋锁: 在自旋锁的基础上, 如果超出失败次数上限(失败次数上限不固定, 由 JVM 调整), 线程将会阻塞.

** 无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁
*Header Word* (Mark Word)
默认存储对象的 HashCode, 分代年龄和锁标志位信息.
这些信息都是与对象自身定义无关的数据, 它会根据对象的锁状态复用自己的存储空间.

*Klass Point*
对象指向它的类元数据的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例.

每一个 Java 对象都有一把看不见的锁, 称为内部锁或 Monitor 锁.
Monitor 是线程私有的数据结构, 每一个线程都有一个可用的 Monitor.

| 无锁     | 0 01 | 对象的hashCode, 对象分代年龄、是否是偏向锁(0)         |
| 偏向锁   | 1 01 | 偏向线程ID, 偏向时间戳, 对象分代年龄, 是否是偏向锁(1) |
| 轻量级锁 | 　00 | 指向栈中锁记录的指针                                  |
| 重量级锁 | 　10 | 指向互斥量(重量级锁)的指针                            |

*简单总结*:
偏向锁通过对比 Mark Word 解决加锁问题, 避免执行CAS操作.
轻量级锁是通过 用CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能.
重量级锁是将除了拥有锁的线程以外的线程都阻塞.

*官方文档*: [[https://wiki.openjdk.java.net/display/HotSpot/Synchronization][OpenJDK - Synchronization and Object Locking]]

[[https://i.loli.net/2020/04/03/1AXmgTt5hp3QdJO.gif]]

插图的右侧是标准的加锁过程, 只要一个对象没有无锁, 标志位一定是 ~01~.
当 synchronized 一个对象时, Header Word 和指向对象的指针会存储在当前栈帧的锁记录中. 然后 VM 尝试通过 CAS 操作将 *指向锁记录的指针* 设置到 Header Word 里.
如果成功, 当前的线程就会拥有锁, 标志位变成 ~00~, 表示这个对象被锁住了.
如果该对象已经被锁, 而导致 CAS 操作失败, VM 会先判断 Header Word 是否指向当前线程的方法栈. 如果是的话, 表示当前线程已经持有锁, 可以进入同步块继续执行.
否则, 该线程通过自旋来获得锁(初始次数为0). 但是当自旋超过一定的次数, 或者一个线程在持有锁, 一个在自旋, 又有第三个来访时, 那么轻量级锁一定会升级成重量级锁来管理等待的线程, 标志位变成 ~10~.
在大多数情况下, 锁总是由同一线程多次获得, 不存在多线程竞争. 所以在 1.6 中引入了偏向锁的技术, 第一个获得该对象锁的的线程 ID 会设置到 Header Word 中. 表示该对象偏向于这个线程.
偏向锁只有遇到其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁, 线程不会主动释放偏向锁.

** 公平锁 vs 非公平锁
- 公平锁: 线程会严格按照获取锁的顺序排队.
- 非公平锁: 线程优先插队, 插队失败才会排队. (RenentrantLock等同步类的默认选择, 性能更优)
